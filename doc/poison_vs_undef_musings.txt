Tradeoffs between poison and undef:

[ ] ANY proposal that uses short-circuit evaluation to remove overflow
taint (regardless of whether it is called poison, undef, or whatever)
appears to avoid the current problems with
simplify-the-control-flow-graph optimization.

[ ] As currently defined, the difference between poison and undef is
that an undef value, when read, may be assumed to be any value convenient for
optimization, while a poisoned value has a definite bit pattern
coupled with a requirement that it never be output.  (In effect,
poison requires the optimizer to do enough static analysis to
guarantee that a poison value can not be output.) 

[ ] In LLVM LangRef, why do they say

	%B= undef
	%C= or %B, %B

	can safely fold to:

	%C= undef

It is unclear if it _must_ safely fold to %C= undef, or does the compiler have
the _option_ of assuming that %B= -1, therefore %C=-1?  I know the manual says
a variable with an undef value can have a different value every time it is
read.  But it still seems like a singularity in the rules that the compiler is
_forbidden_ to assume that 2 undef values are the same when this would produce a
very useful optimization, such as the above %C.

[ ] David and Nuno's proposal seems like a highly simplified explanation of
the current LangRef's undef handling rules.  For example, they say, "if either
operand is undef, then the result is undef."  Do they indend to keep the
current undef handling rules (which seem superficially compatible with their
proposal), or do they see any differences in how undef is handled?

[ ] The current standard says, "poison values behave like undef values...".
Since the undef handling rules imply short-circuit handling for undef, is
applying short-circuit propogation of poison merely a clarification of the
existing rules?

(end of file)

