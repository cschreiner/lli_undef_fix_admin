
Compilers optimize code to make it run faster:

For example:
in C: 
   timeout= timeout / 4;

in unoptimized pseudo-assembler:
	r1= LOAD @timeout
	r2= DIV r1, 4;
	STORE @timeout, r2 

in optimized pseudo-assembler:
	r1= LOAD @timeout
	r2= ARITHMETIC_SHIFT_RIGHT r1, 2;
	STORE @timeout, r2 

On modern processors, the shift instruction usually runs about 10x
faster than a "div" instruction.

But some optimizations don't hold for all data values.
{TODO: find an example, preferably involving a poison issue}

in C:
   unsigned compute_tax ( unsigned income ) 
   {
      tax= income* FEDERAL_RATE/ 100 + income* STATE_RATE/ 100;
      return tax;
   }

optimized to:
   unsigned compute_business_tax ( unsigned income ) 
   {
      // One division fewer!  One multiplication fewer!  
      tax= income * (FEDERAL_RATE+ STATE_RATE)/ 100; 
      return tax;
   }

What happens when the business grows enough that variable "income" exceeds 1
billion?  (Assume a 32-bit integer length.)

The LLVM compiler family calls the results in these corner cases "poison".  
If the optimized assembler code can ever generate a poison value, AND the
poison value can be output (as opposed to being dropped), the optimization is
dangerous and must be avoided.

And sometimes, when the optimization does not hold, it does not matter.
{TODO: find an example}

Research tack: create a tool that checks for poison values and halts when they
are output.  This has shown that some optimizations thought to be correct
inadvertantly create poison values under some circumstances.

Some definitions of poison are themselves ambiguous.

{TODO: insert the example of generating a poison value, bitshifting it left 8
places, and then masking off the high order bits, leaving only the lower 8.

Research tack: create a formal, mathematical definition of poison that can be
used to verify proposed compiler optimizations.

Research tack: compare formal poison definitions with the intuitive
expectations of the compiler development community, and justify discrepancies.

Research tack: make sure that formal poison definitions still allow compilers
to optimize code enough that end-users' applications run reasonably quickly.

(end of poster)






   

