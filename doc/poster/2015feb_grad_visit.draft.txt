
==============================================================================
slide 1

Compilers optimize code to make it run faster:

For example:
in C: 
   timeout= timeout / 4;

in unoptimized pseudo-assembler:
	r1= LOAD @timeout
	r2= DIV r1, 4;
	STORE @timeout, r2 

in optimized pseudo-assembler:
	r1= LOAD @timeout
	r2= SHIFT_RIGHT r1, 2;
	STORE @timeout, r2 

On modern processors, the shift instruction usually runs about 10x
faster than a "div" instruction.

==============================================================================
slide 2

But some optimizations don't hold for all data values.

in C:
   unsigned compute_tax ( unsigned income ) 
   {
      tax= income* FEDERAL_RATE/ 100 + income* STATE_RATE/ 100;
      return tax;
   }

optimized to:
   unsigned compute_business_tax ( unsigned income ) 
   {
      // One division fewer!  One multiplication fewer!  
      tax= income * (FEDERAL_RATE+ STATE_RATE)/ 100; 
      return tax;
   }

{TODO: should this question be on the next "slide"?}  What happens when the
business grows enough that the variable "income" exceeds 1 billion?  (Assume a
32-bit integer length. The sum of the two tax rates is at least 10.)

==============================================================================
slide 3

The LLVM compiler family calls the results in these corner cases "poison".  
If the optimized assembler code can ever generate a poison value, AND the
poison value can be output (as opposed to being dropped), the optimization is
dangerous and must be avoided.

Does this generate poison?  If so, where, and why?

   int16_t compute_result( int16_t aa )
   {
      return 75 << aa;
   }

   int16_t foo= compute_result( 20 );


==============================================================================
slide 4

Summary of rules for handling poison:

[ ] Once a poison value is generated, all values derived from it are also
poison.

[ ] Poison can be passed into a function, and/or returned from a function.

[ ] A value remains poisoned when stored in memory, and when recalled from
memory.

Note that in the common case that the argument values passed to functions are
not known at compile time, the compiler can not ignore any possible argument
values when optimizing.

Does this generate poison?  If so, where, and why?

   int get_answer( int xx )
   {
      return (xx- 1)/ -1;
   }

   get_answer( INT_MIN+ 1 );


==============================================================================
slide 5

Consider this code:

  int16_t do_something( int16_t aa, int16_t bb )
  {
      int16_t result= aa- 16;
      if ( bb < 0 )  {
         result= result+ bb;
      }
      return result;
  }

  int16_t foo= do_something( INT16_MIN+ 1, 45 );

Question: Does this generate poison?  If so, where, and why?

==============================================================================
slide 6

Sometimes, when code generates poison, it does not matter.  

Note that branching is expensive. (It forcibly clears the processor's
instruction decoding pipeline, and while branch prediction is useful, it is
not nearly as accurate as one would hope.)  Many optimizations go to great
lengths to eliminate branches.

   int16_t irrelevant_poison( int16_t xx, int16_t yy )
   {
      int16_t result= xx;
      if ( yy > 7 )  {
         result= xx+ 7;
      } else {
         result= xx* 2+ 3;
      }
      return result;
   }

   irrelevant_poison( 32770, -1 );

This often gets optimized into the following code, which generates poison.  Is
the final return value poisoned?  Why or why not?

   int16_t irrelevant_poison( int16_t xx, int16_t yy )
   {
      int16_t tmp1= xx+ 7;
      int16_t tmp2= xx* 2+ 3;
      return (yy > 7) ? tmp1 : tmp2;
   }

   int16_t foo= irrelevant_poison( 32770, -1 );

==============================================================================
slide 7

Research tack: create a tool that detects poison values, traces them, and
halts when they are output.  This has shown that some optimizations thought to
be correct inadvertantly create poison values under some circumstances.

==============================================================================
slide 8

Some definitions of poison are themselves ambiguous.

in C:
   int16_t seed= INT16_MAX- 1;
   
   seed+= 5; // generates poison
   seed= seed << 8;
   seed= seed & 0xff;

Should "seed" contain poison?  Should the programmer expect a specific
value for "seed", or can an optimizer insert any value it desires?

The current compiler specification defines poison rather vaguely.  It is a
tribute to the intuition and intelligence of the compiler contributors that
this has worked so far.  We have been lucky.  But we find it does not work for
the next generation of compiler optimizations.

Research tack: create a formal, mathematical definition of poison that can be
used to verify proposed compiler optimizations.

==============================================================================
slide 9

The formal poison specification has to make enough sense to the compiler
maintainers that they can understand and use our results.

Research tack: compare formal poison definitions with the intuitive
expectations of the LLVM compiler development community, and justify
any discrepancies.

And, of course, the results have to still allow enough optimization
that end-users' applications run reasonably quickly.

Research tack: make sure that as many existing optimizations as possible are
still possible.  Verify speed and accuracy differences on end-user
applications.

==============================================================================


(end of poster)






   

