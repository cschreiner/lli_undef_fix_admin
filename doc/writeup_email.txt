Writeup of Poison Research in project lli_undef_fix
----------------------------------------------------

\TODO{make sure I'm using "poison specification" and "poison rules"
consistently.}

The current specification of poison handling has holes, which have been
patched in the current LLVM implementation by human intuition and dilligent
debugging efforts.  Unfortunately, different people have different intuitive
understandings of how poison should work. \TODO{cite the discusssions of
poison on LLVM mailing list} This situation makes a precise formal definition
of poison handling impossible, allows occasional miscompilation in corner
cases, and prevents the compiler from applying many next generation compiler
optimizations.

We, the authors, have been studying the effects of different poison handling
rules on thousands of C programs to see what the practical effects of
different rules.  To do this, we created an LLVM IR interpreter capable of
applying different poison handling rules, and set it to halt with an error
message when a poison value was being output, written to a volatile memory
location, or passed to a function call running outside the interpreter.  The C
programs were generated by CSmith, a tool that has proven useful in the past
for finding compiler bugs by generating programs that vigorously exercise a
compiler.  Other C programs were obtained from \TODO{add sources}.

The key findings from these experiments are:

[ ] The current specification prohibits removing poison from a sequence of
computations, once the poison is generated.  In other words, if value a is
poisoned, then f(a) is always poisoned, as is g(f(a)), all computations
following a branch on a, and all other values depending in any sense on a.
This guarantees that a program created by a fully conforming compiler must
either perform expensive checks before each computation to guarantee that
poison will never be generated, or that eventually most values computed will
be poisoned.  These expensive checks prohibit the optimizer from simplifying
the control flow graph, which is a significant factor in speeding up program
exection on many modern processors.

[ ] The above problem can be circumvented by applying a conceptually simple
rule: poison does not propogate past a computation whose result is independent
of the poison value.  For example, if value a is poisoned, then (a AND 0) is
not poisoned.  Similarly, (a OR 1) is not poisoned, nor (a * 0), nor the
result of a select statement that returns an unpoisoned argument (e.g. select
1, 45, a).  This rule is sufficient to eliminate most \TODO{all?} poisoned
outputs by the programs we tested.


\TODO{add conclusion}
