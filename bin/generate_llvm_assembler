#!/usr/bin/perl
#
# ****************************************************************************
# Project Name: lli_undef_fix
# Script Name: generate_llvm_assembler.pl 
#
#
# For a copyright information, see the statement in the POD documentation at
# the end of this file.  
#
# Description: see POD documentation
#	
# ****************************************************************************

# ****************************************************************************
# Revision Control Information (customized for RCS)
#
# $Revision: 1.2 $
# $Date: 2014/01/23 21:23:34 $
# $Author: cas $
#
# ****************************************************************************


# ****************************************************************************
# Compiler Directives (use's)
# make sure we are using this Perl version or later
use 5.10.0;

use strict;
use Getopt::Long;
use Config;
use File::Spec;
use FileHandle;

# ****************************************************************************
# package identification

#package generate_llvm_assembler;


# ****************************************************************************
# package BEGIN and END functions

   # =========================================================================
   # subroutine BEGIN
   # =========================================================================
   sub BEGIN
   {{
      # set basic constants, which should be defined in all scripts
      use vars qw ( *TRUE *FALSE *PERL_SUCCESS *PERL_FAILURE
            *EXIT_SUCCESS *EXIT_FAILURE );
      *TRUE= \1;
      *FALSE= \0;
      *PERL_SUCCESS= \1;
      *PERL_FAILURE= \0;
      *EXIT_SUCCESS= \0;
      *EXIT_FAILURE= \-1;

      use vars qw ( *HELP_TYPE_EMERGENCY *HELP_TYPE_FULL
            *HELP_TYPE_MAN  *HELP_TYPE_REVISION );
      *HELP_TYPE_EMERGENCY= \2960; # number chosen at random
      *HELP_TYPE_FULL= \2961; # one more than the above
      *HELP_TYPE_MAN= \2962; # one more than the above
      *HELP_TYPE_REVISION= \2963; # one more than the above

      # ----------------------------------------------------------------------
      # script-specific constants
      use vars qw ( *scriptname $revision *SCRIPT_COPYRIGHT_YEAR 
	    $debug_flag );
      *scriptname= \"generate_llvm_assembler.pl";
      {
         my ($null);
         ($null, $revision)= split / /, '$Revision $';
         $revision=~ tr/$/ /s;
      }
      *SCRIPT_COPYRIGHT_YEAR= \2014;
      $debug_flag= $FALSE;

      # ----------------------------------------------------------------------
      # set library search paths

      use FindBin;
      use lib "$FindBin::Bin/../lib";

      if ( exists($ENV{'USR_CAS_LIB'}) )  {
         push @INC, File::Spec->catdir( $ENV{'USR_CAS_LIB'} . 'perl' );
      }

      # ----------------------------------------------------------------------
      # require's and use's needed in the BEGIN block


      # ----------------------------------------------------------------------
      # script-wide config options

      # use synchronous I/O
      $|= $main::TRUE;


      # ----------------------------------------------------------------------
      # other stuff

   }}

   # =========================================================================
   # require's and use's needed by the rest of the program
   # =========================================================================

   # =========================================================================
   # subroutine END
   # =========================================================================
   sub END
   {{
      
   }}

# ****************************************************************************
# start the script

## ===========================================================================
##   set debug mode

if ( scalar(@ARGV) > 0 )  {
   if ( $#ARGV >= $[ )  { 
      if ( $ARGV[$[] eq "debug"  )  { 
	 $debug_flag= $TRUE;
	 shift @ARGV; print "$scriptname running in debug mode \n";
      } 
   } 
}

## ===========================================================================
##   get command line args

use vars qw ( $arg_outfile_name );
use vars qw ( $arg_bitwidth $arg_start_poison $arg_num_steps );
$arg_bitwidth= undef; # causes choosing a random value, later.
$arg_start_poison= $main::FALSE;
$arg_num_steps= 10;

use vars qw( $need_to_exit );
$need_to_exit= $FALSE;

## -----------------------------------------------------------------------
##   set up defaults


## -----------------------------------------------------------------------
##   parse arguments that GetOpt can't handle

if ( scalar(@ARGV) > 0 )  {
   if ( $ARGV[ $[ ] eq "help" ||
	 $ARGV[ $[ ] eq "-help" )  {
      shift @ARGV;
      &give_help ( $HELP_TYPE_FULL );
   }
}

## -----------------------------------------------------------------------
##   run GetOpt

{
   my ( $arg_help, $arg_man, $arg_revision );

   eval {
      Getopt::Long::Configure ( 'no_auto_abbrev', 'no_getopt_compat',
            'permute', 'bundling', 'no_ignore_case', 'no_pass_through' );
   };
   if ( $@ ne "" )  {
      eval {
         # try again, using the older Getopt::Long call
         &Getopt::Long::config ( 'no_auto_abbrev', 'no_getopt_compat',
               'permute', 'bundling', 'no_ignore_case', 'no_pass_through' );
      };
      if ( $@ ne "" ) { die; }
   }

   GetOptions ( "help|h" => \$arg_help, 
	 "man" => \$arg_man,
	 "revision" => \$arg_revision,
         "bitwidth=i" => \$arg_bitwidth,
         "start-poison" => \$arg_start_poison,
         "num-steps=i" => \$arg_num_steps,
	 );

   if ( $arg_help )  {
      &give_help ( $HELP_TYPE_FULL );
      $need_to_exit= $main::TRUE;
   } elsif ( $arg_man )  {
      &give_help ( $HELP_TYPE_MAN );
      $need_to_exit= $main::TRUE;
   } elsif ( $arg_revision )  {
      &give_help ( $HELP_TYPE_REVISION );
      $need_to_exit= $main::TRUE;
   }
      
}

if ( $need_to_exit )  { print "\n"; exit $EXIT_FAILURE; }


## -----------------------------------------------------------------------
##   parse arguments that GetOptions left behind

$arg_outfile_name= shift @ARGV;

## -----------------------------------------------------------------------
##   check arguments

if ( $need_to_exit )  { print "\n"; exit $EXIT_FAILURE; }

## -----------------------------------------------------------------------
##   print out arguments
if ( $debug_flag )  {


}


## ===========================================================================
##  set up constants

our( %opcode_hash )=  (
      'add' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( nsw nuw ) ],
	 },
      'sub' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( nsw nuw ) ],
	 },
      'mul' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( nsw nuw ) ],
	 },
      'sdiv' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( exact ) ],
	 },
      'udiv' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( exact ) ],
	 },
      'srem' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( ) ],
	 },
      'urem' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( ) ],
	 },
      'and' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( ) ],
	 },
      'or' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( ) ],
	 },
      'xor' => {
	 'type'=> 'arith',
         'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( ) ],
	 },
      'shl' => {
	 'type'=> 'shift',
         'gen_ftn' => 'generate_shift_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( nsw nuw ) ],
	 },
      'lshr' => {
	 'type'=> 'shift',
         'gen_ftn' => 'generate_shift_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( exact ) ],
	 },
      'ashr' => {
	 'type'=> 'shift',
         'gen_ftn' => 'generate_shift_inst', # change this to a ftn ptr
         'flag_listref' => [ qw( exact ) ],
	 },
      # template: is 4 lines long:
      #'xxx' => {
      #	 'type'=> 'arith',
      #   'gen_ftn' => 'generate_arith_inst', # change this to a ftn ptr
      #   'flag_listref' => [ qw( ) ],
      #	 },
      );

## ===========================================================================
##   set up for this run

our( $regWidth )= new Bitwidth( $arg_bitwidth );

## ===========================================================================
##   set up output file

our( $out_fh )= new FileHandle;
$out_fh->open( ">" . $arg_outfile_name ) or
   die $main::scriptname . ": can't open output file for writing, \n" .
         "\t" . "file=\"$arg_outfile_name\",\n" .
         "\t" . "$!. \n";

## ===========================================================================
##   start generating

$out_fh->print( "; autogenerated by $main::scriptname. \n" );
$out_fh->print( "\n" );

$out_fh->print( "\@printf_st = private unnamed_addr constant [37 x i8] " . 
      "c\"this prints if poison-free: '0x%x' \\0A\\00\"\n" );
$out_fh->print( "\n" );
$out_fh->print( "; external declaration of the printf(~) function \n" );
$out_fh->print( "declare i32 \@printf(i8* nocapture readonly, ...)\n" );
$out_fh->print( "\n" );

$out_fh->print( "define " . $regWidth->getName() . ' @main()' . " { ; \n" );
$out_fh->print( "  ; \%convert [? x i8]* to i8* \n" );
$out_fh->print( "  \%printf_st_i8 = getelementptr [37 x i8]* \@printf_st, " . 
    "i64 0, i64 0\n" );
$out_fh->print( "\n" );

$out_fh->print( generate_const_inst( $regWidth ) );
$out_fh->print( generate_const_inst( $regWidth ) );

if ( $arg_start_poison )  {
   $out_fh->print ( "  " . reg_context::getName() . 
	 "= sub nuw " . $regWidth->getName() . " 0, 1 ; generates POISON \n" );
   # TODO2: replace the above operands with random numbers
}

## ===========================================================================
##   generate bulk of the instructions

for ( my $step_num= 0; $step_num < $arg_num_steps; $step_num++ )  {
   $out_fh->print ( generate_one_inst( $regWidth ) );
}

## ===========================================================================
##   write out end of program

$out_fh->print( "\n" );
$out_fh->print( "  call i32 (i8*, ...)* \@printf(i8* \%printf_st_i8, " .
      $regWidth->getName() . ' ' . reg_context::getPrevName() . ")\n" );

$out_fh->print( "\n" );
$out_fh->print( "  ; clean up and return \n" );
$out_fh->print( "  ret " . $regWidth->getName() . " 0 \n" );
$out_fh->print( "} \n" );

## ===========================================================================
##   clean up output file and exit

$out_fh->close() or
   die $main::scriptname . ": can't close output file after writing, \n" .
         "\t" . "file=\"$arg_outfile_name\",\n" .
         "\t" . "$!. \n";
exit( $main::EXIT_SUCCESS );

## ===========================================================================
##   

## ===========================================================================
##   

## ===========================================================================
## Subroutine generate_one_inst()
## ===========================================================================
# Description: generates one assembler instruction
#
# Method: 
#
# Notes: 
#
# Warnings: 
#
# Inputs: 
#   $regWidth: a regWidth instance with info on the size of integers to use
# 
# Outputs: 
#   
#
# Return Value: 
#   a string containing the instruction
#
# ============================================================================
sub generate_one_inst
{{
   my( $regWidth )= @_;

   my( $opcode );
   {
      my( @opcode_list )= keys %opcode_hash;
      $opcode= $opcode_list[ int( rand() * scalar(@opcode_list) ) ];
      if ( $main::debug_flag )  {
	print "selected opcode=\"$opcode\"\n";
      }
   }

   my( $inst );
   if ( $opcode_hash{$opcode}->{'type'} eq 'arith' )  {
      $inst= generate_arith_inst( $regWidth, $opcode );
   } elsif ( $opcode_hash{$opcode}->{'type'} eq 'shift' )  {
      $inst= generate_shift_inst( $regWidth, $opcode );
   } else {
      die $main::scriptname . 
	    ": don't recognize opcode type for \"$opcode\", \"" . 
	    $opcode_hash{$opcode}->{'type'} . "\"\n";
   }

   return $inst;
}}


## ===========================================================================
# Subroutine generate_storeload_insts()
# ===========================================================================
# Description: generates a store instruction, immediately followed by a load
#	instruction.  The idea is to make sure every value gets stored also
#	gets loaded later in the program.
#
# Method: 
#
# Notes: 
#
# Warnings: 
#
# Inputs: 
#   $regWidth: info on integer size to use, per generate_one_inst()
#   $opcode: the opcode to generate
# 
# Outputs: none
#   
# Return Value: a list with these elements:
#   string containing pre-function definitions related to the generated 
#	instructions
#   string containing the instruction generated
#
# ============================================================================
sub generate_storeload_insts
{{
   my( $regWidth, $opcode )= @_;

   my( $addr_name )= '@addr_';
   for ( my $ii= 0; $ii < 4; $ii++ )  {
      # This assumes that the character encoding has the lower-case codepoints
      # be consecutive.
      $addr_name.= chr( ord('a')+ int(26*rand()) );
   }
   my( $pre_func )= $addr_name . " = global " . $regWidth->getName() . "\n";

   my( $dest_reg )= reg_context::getName();
   my( $src_reg )= reg_context::getPrevName(1);

   my( $store_flags )= " ";
   if ( rand() < .5 )  {
      $store_flags= "volatile ";
   }
   # recall that flags strings must always end in a space

   my( $inst );
   $inst.= "  " . "store " . 
         $store_flags . $regWidth->getName() . ' ' . $src_reg . ', ' . 
         $regWidth->getName() . '* ' . $addr_name . "\n";
   $inst.= "  " . "load " . $regWidth->getName() . "* $addr_name \n";
   # TODO2: consider adding an 'align 4' or similar to the load and 
   # store instructions.

   return ( $pre_func, $inst );
}}

## ===========================================================================
## Subroutine generate_shift_inst()
## ===========================================================================
# Description: generates a shift instruction.  Shift instructions 
#	use a register value for one argument, and randomly generated
#	constant for the other.  This guards against the constant
#	being larger than the number of bits in the register.
#
# Method: 
#
# Notes: 
#
# Warnings: 
#
# Inputs: 
#   $regWidth: info on integer size to use, per generate_one_inst()
#   $opcode: the opcode to generate
# 
# Outputs: none
#   
# Return Value: a list with these elements:
#   string containing pre-function definitions related to the generated 
#	instructions
#   string containing the instruction generated
#
# ============================================================================
sub generate_shift_inst
{{
   my( $regWidth, $opcode )= @_;

   my( $dest_reg )= reg_context::getName();

   my( $flags )= "";
   my( $flag_listref )= $opcode_hash{$opcode}->{'flag_listref'};
   for ( my $ii= 0; $ii < scalar(@$flag_listref); $ii++ )  {
      if ( rand() < .5 )  {
	 # a flag must ALWAYS end in a space. 
         $flags.= $$flag_listref[$ii] . " ";
      }
   } 

   my( $operand1 )= reg_context::getPrevName(1);

   my( $operand2 );
   # operand is a constant
   $operand2= $regWidth->getRandShiftVal();
   
   my( $inst )= "  " . $dest_reg . "= " . $opcode . ' ' . 
	 $flags . $regWidth->getName() . ' ' .
	 $operand1 . ', ' . $operand2 . "\n";

   return $inst;
}}

## ===========================================================================
## Subroutine generate_arith_inst()
## ===========================================================================
# Description: generates an arithmetic instruction.  Arithmetic instructions 
#	use a register value for one argument, and either a register or a 
#	literal value for the other.  These arguments can be in either order. 
#
# Method: 
#
# Notes: 
#
# Warnings: 
#
# Inputs: 
#   $regWidth: info on integer size to use, per generate_one_inst()
#   $opcode: the opcode to generate
# 
# Outputs: none
#   
# Return Value: 
#   string containing the instruction generated
#
# ============================================================================
sub generate_arith_inst
{{
   my( $regWidth, $opcode )= @_;

   my( $dest_reg )= reg_context::getName();

   my( $flags )= "";
   my( $flag_listref )= $opcode_hash{$opcode}->{'flag_listref'};
   for ( my $ii= 0; $ii < scalar(@$flag_listref); $ii++ )  {
      if ( rand() < .5 )  {
	 # a flag must ALWAYS end in a space. 
         $flags.= $$flag_listref[$ii] . " ";
      }
   } 

   my( $operand1 )= reg_context::getPrevName(1);

   my( $operand2 );
   if ( rand() < .5 )  {
      # operand is a constant
      $operand2= $regWidth->getRandVal();
   } else {
      $operand2= reg_context::getRecentName();
   }
   
   # maybe swap operands
   if ( rand() < .5 )  {
      my( $tmp )= $operand1;
      $operand1= $operand2;
      $operand2= $tmp;
   }

   my( $inst )= "  " . $dest_reg . "= " . $opcode . ' ' . 
	 $flags . $regWidth->getName() . ' ' .
	 $operand1 . ', ' . $operand2 . "\n";

   return $inst;
}}

## ===========================================================================
## Subroutine generate_const_inst()
## ===========================================================================
# Description: generates a constant-assignment instruction.  A constant 
#	assignment instruction assigns a constant to a register. 
#
# Method: This has to be implemented by adding 0 to a constant.  Sheesh.
#
# Notes: 
#
# Warnings: 
#
# Inputs: 
#   $regWidth: info on integer size to use, per generate_one_inst()
#   
# Outputs: none
#   
# Return Value: 
#   string containing the instruction generated.  String contains a EOL.
#   
# ============================================================================
sub generate_const_inst
{{
   my( $regWidth )= @_;

   my( $inst )= "  " . 
	 reg_context::getName(). "= add ". $regWidth->getName(). ' ' . 
         $regWidth->getRandVal() . ", 0 \n";
   return $inst;
}}


# template 25 lines long
## ===========================================================================
## Subroutine name()
## ===========================================================================
# Description: 
#
# Method: 
#
# Notes: 
#
# Warnings: 
#
# Inputs: 
#   
# 
# Outputs: 
#   
#
# Return Value: 
#   
#
# ============================================================================
#sub name
#{{
#   my( )= @_;
#}}



## ===========================================================================
## Subroutine system_wrapper()
## ===========================================================================
# Description:
#	Call the first argument the command, and the 2nd argument the 
#	alternate command.
#
#	If not running in debug mode, executes the command via a
#	system() call.
#
#	If running in debug mode, prints the command, and executes 
#	the alternate command.  If the alternate command is not present, 
#	assumes it is the same as the command.	If the alternate command is
#	a null string, does nothing and returns as if the command had 
#	succeeded.
#
# Method:
#
# Notes:
#
# Warnings:
#
# Inputs:
#	$cmd: the command described above
#	$alt_cmd: the alternate command described above
# 
# Outputs:
#	none
#
# Return Value:
#   a list, giving the following:
#   * the command's exit code 
#   * a boolean flag that is true iff the command's process dumped core
#   * the signal that caused the command's to exit (if it exited due to 
#	a signal)
#
# ============================================================================
sub system_wrapper
{{
   my ( $raw_exit_code )= 0;
   my ( $ftn_name )= "system_wrapper()";

   # parse args
   my( $cmd, $alt_cmd );
   {
      my ($cmd_index)= $[;
      my ($alt_cmd_index)= $[+ 1;
      if ( $#_ == $cmd_index)  {
	 $cmd= $_[$cmd_index];
	 $alt_cmd= $cmd;
      } elsif ( $#_ == $alt_cmd_index )  {
	 $cmd= $_[$cmd_index];
	 $alt_cmd= $_[ $alt_cmd_index ];
      } else {
	 die "$scriptname:$ftn_name: " . 
	       "internal error 202.11dec1999, code= $#_ \n";
      }
   }

   # run the command
   if ( $debug_flag )  {
      print "$scriptname:$ftn_name: would execute \"$cmd\" \n";
      if ( $alt_cmd eq "" )  {
	 $raw_exit_code= 0;
      } else {
	 $raw_exit_code= system( $alt_cmd );
      }    
   } else {
      $raw_exit_code= system( $cmd );
   }

   # divide up the exit code 
   return ( $raw_exit_code >> 8, 
	 ($raw_exit_code & 128) == 0 ? $FALSE : $TRUE,
	   $raw_exit_code & 127 );
}}



## ===========================================================================
## Subroutine give_help()
## ===========================================================================
# Description:
#	Gives a help message or a man page.
#
# Method:
#
# Notes:
#
# Warnings:
#
# Inputs:
# 
# Outputs:
#
# Return Value:
#
# ============================================================================
sub give_help
{{
   my( $help_type )= @_;
   my ($H)= "   ";

   # ----------------------------------------------------------------------
   # print revision information
   if ( $help_type == $HELP_TYPE_REVISION )  {
      print "$scriptname: revision $revision \n\n";
      exit $EXIT_SUCCESS;
   }

   # ----------------------------------------------------------------------
   # print manual page
   if ( $help_type == $HELP_TYPE_MAN )  {
      my ($cmd);
      my ( $needs_to_run )= $main::TRUE;

      # CAS todo: Need to improve ability to find the perldoc program if 
      # it isn't on the current path.  Ideally, we should look for the
      # perldoc program where the operating system found the perl 
      # executable, and if the perl executable is a symbolic link, 
      # look for the perldoc executable in the directory of the file 
      # the symbolic link points to.

      # repeatedly look for the perldoc program until it runs successfully
      foreach my $dir ( "", $Config{'bin'}, $Config{'binexp'}, 
	    $Config{'installbin'}, $Config{'installsitebin'}, 
	    $Config{'installvendorbin'}, $Config{'sitebin'}, 
	    $Config{'sitebinexp'}, $Config{'vendorbin'}, 
	    $Config{'vendorbinexp'} )  {
	 $cmd= File::Spec->catfile ( $dir, "perldoc" ) . " $0";
	 my ( $exit_status, $core_dump, $exit_signal )=
	       &system_wrapper ( $cmd, "" );
	 if ( $exit_status == 0 )  {
	    $needs_to_run= $main::FALSE;
	    last;
	 }
      }
      if ( $needs_to_run )  {
	 print "$scriptname: problem running `perldoc` to format the manual
	page.  Is perldoc in a directory on your program search PATH?  
	Use `$scriptname --help` for more information on $scriptname. \n\n";
         exit $main::EXIT_FAILURE; 
      }
      exit $main::EXIT_SUCCESS; 
   }
   

   # ----------------------------------------------------------------------
   # print header
   if ( $help_type == $HELP_TYPE_FULL )  {
      print "$scriptname: no description available \n";
      if ( $help_type == $HELP_TYPE_FULL )  {
	 print "revision $revision \n";
      }
      print "\n";
   }

   
   # ----------------------------------------------------------------------
   # print synopsis
   
   if ( $help_type == $HELP_TYPE_EMERGENCY || $help_type == $HELP_TYPE_FULL )  {
      print "Correct use: \n";
   }


   print $H . 
	 "$scriptname [debug] [-h|help|-help|--help] [--man] [--revision] \n";
   print $H . "$scriptname [debug] ? \n";
   print "\n\n";

   # ----------------------------------------------------------------------
   # exit unless we're print a man page
   if ( $help_type == $HELP_TYPE_EMERGENCY )  {
      #print "\n\n";
      exit $EXIT_FAILURE;
   }
   if ( $help_type == $HELP_TYPE_FULL )  {
      #print "\n\n";
      exit $EXIT_SUCCESS;
   }

   die "$scriptname: internal error 372.4nov2000. \n";
   
}}



# ****************************************************************************
# end this package 
package main;


## ****************************************************************************
## ****************************************************************************
package reg_context;
# Description: information for selecting registers

## ****************************************************************************
## package BEGIN and END functions

   # =========================================================================
   # subroutine BEGIN
   # =========================================================================
   sub BEGIN
   {{
      # ----------------------------------------------------------------------
      # package-specific constants
      use vars qw ( $packagename );
      $packagename= "reg_context";

      # ----------------------------------------------------------------------
      # other stuff

      use constant MIN_REG_NUM => 1;

      use vars qw ( $reg_num );
      $reg_num= MIN_REG_NUM; # llvm requires the first register to be %1


   }}

   # =========================================================================
   # subroutine END
   # =========================================================================
   sub END
   {{
      
   }}

## ****************************************************************************
## start the package

## ===========================================================================
## Subroutine getName
## ===========================================================================
# Description: returns the name of a new register
#
# Inputs: none
# 
# Outputs: none
#
# Return Value: per description
#
# ============================================================================
sub getName
{{
   #my( )= @_;
   my( $ret_val )= "%" . $reg_num;
   $reg_num++;
   return $ret_val;
}}

## ===========================================================================
## Subroutine getPrevName
## ===========================================================================
# Description: gets the name of the nth previously issued register
#
# Inputs: 
#   $steps: the number of steps back to go. 0 (the default) indicates the 
#	absolute most recently issued register, 1 is the one before that, 
#	and so forth.
# 
# Outputs: none
#
# Return Value: per description
#
# ============================================================================
sub getPrevName
{{
   my( $steps )= @_;
   my( $steps2 )= $steps;
   if ( ! defined($steps) )  { $steps2= 0; }

   if ( ($reg_num- 1 - $steps) < 0 )  {
      die $main::scriptname . 
	    ": internal error 2014nov24_154228, " . 
	    "codes=\"$reg_num\", \"$steps\"\n";
   }
   return "%" . ($reg_num- 1- $steps2);
}}

## ===========================================================================
## Subroutine getRecentName
## ===========================================================================
# Description: gets the name of a recently issued register
#
# Inputs: none
# 
# Outputs: none
#
# Return Value: per description
#
# ============================================================================
sub getRecentName
{{
   #my( )= @_;
   my( $limit )= 10;
   my( $max_returnable_reg_num )= $reg_num- 3;
   if ( $max_returnable_reg_num < $limit )  { 
      $limit= $max_returnable_reg_num; 
   };
   my( $rr )= $max_returnable_reg_num- int( rand()*$limit );
   if ( $rr < MIN_REG_NUM )  {
      die $main::scriptname . 
	    ": internal error 2014nov24_210556, code=\"$rr\"\n";
   }
   return "%" . $rr;
}}

#template is 16 lines long
## ===========================================================================
## Subroutine sub_name
## ===========================================================================
# Description:
#
# Inputs:
# 
# Outputs:
#
# Return Value:
#
# ============================================================================
#sub sub_name
#{{
#   my( )= @_;
#}}

## ===========================================================================
## Short get subroutines
## ===========================================================================
# Description: short subroutines that only get one field
#
# Inputs: none
#
# Return Value: the field's value
#
# ============================================================================
#sub sub_name
#{{
#   return ;
#}}

## ===========================================================================
## Short set subroutines
## ===========================================================================
# Description: short subroutines that only set one field
#
# Inputs: the field's new value
#
# Return Value: none
#
# ============================================================================
#sub sub_name
#{{
#   my ($ii)= @_;
#}}




## ****************************************************************************
## end this package 
package main;
## ****************************************************************************
## ****************************************************************************

## ****************************************************************************
## ****************************************************************************
package Bitwidth;

## ****************************************************************************
## package BEGIN and END functions

   # =========================================================================
   # subroutine BEGIN
   # =========================================================================
   sub BEGIN
   {{
      # ----------------------------------------------------------------------
      # package-specific constants
      use vars qw ( $packagename );
      $packagename= "Bitwidth";

      # ----------------------------------------------------------------------
      # other stuff

   }}

   # =========================================================================
   # subroutine END
   # =========================================================================
   sub END
   {{
      
   }}

## ****************************************************************************
## start the package

## ===========================================================================
## Subroutine new
## ===========================================================================
# Description: creates a new instance
#
# Inputs:
#   $class: information about the class (provided by perl)
#   $target_width: an integer indicating the preferred with to work with.
#	If undefined, a random value will be chosen.
# 
# Outputs: none
#
# Return Value: a new instance
#
# ============================================================================
sub new
{{
   my( $class, $target_width )= @_;

   my( $perl_this )= {};
   bless $perl_this, $class;

   # TODO3: adjust this to exactly handle 64+-bit integers
   my( $max_width )= 32;
   my( $abs_min_width )= 1;
   my( $pref_min_width )= 6;
   my( $width );
   if ( $target_width eq "" )  {
      $width= int( rand()*($max_width-$pref_min_width) + $pref_min_width );
   } else {
      if ( $target_width < $abs_min_width or $target_width > $max_width )  {
	 die $main::scriptname . ": bitwidth out of range. \n";
      }
      $width= $target_width;
   }
   $perl_this->{'bitwidth'}= $width;
   $perl_this->{'maxVal'}= 2** $width- 1;
   $perl_this->{'minVal'}= 0;
   $perl_this->{'name'}= "i" . $width;

   return $perl_this;
}}

## ===========================================================================
## Subroutine getRandVal
## ===========================================================================
# Description: returns a random value for this size of integer
#
# Inputs:
#   $perl_this: the instance in question (provided by PERL)
#   $margin: do not return a value within this distance of the min or max value.
#	Defaults to 0.  This guarantees that the value returned can be 
#	incremented or decremented by up to this amount without overflow.
# 
# Outputs: none
#
# Return Value: per Description
#
# ============================================================================
sub getRandVal
{{
   my( $perl_this, $margin )= @_;

   my( $margin2 )= $margin;
   if ( !defined($margin) )  { $margin2= 0; }

   my( $range )= $perl_this->{'maxVal'} - $perl_this->{'minVal'}- 2*$margin2;
   if ( $main::debug_flag )  {
     print "max=\"" . $perl_this->{'maxVal'} . "\", min=\"" . 
	   $perl_this->{'minVal'} . "\", margin2=\"$margin2\"\n";
     print "range=\"$range\"\n";
   }
   my $val= int( rand() * $range+ $perl_this->{'minVal'}+ $margin2 );

   return $val;
}}

## ===========================================================================
## Subroutine getRandShiftVal
## ===========================================================================
# Description: returns a random number from 0 to this instance's bitwidth. 
#	This is the legal range that a register may be shifted right or left.
#
# Note: strange, shifting by the width of the register is sometimes allowed 
#	and sometimes not.  For example, 
#	   %9= lshr i13 %8, 13
#	   %11= ashr  i13 %10, 13
#	are ok, but
#	   %9= lshr exact i13 %8, 13
#	and
#	   %11= ashr exact i13 %10, 13
#	are not.  Even though the 'exact' flag is supposted to generate
#	poison if 0 bits are shifted out, its presence causes
#	execution to halt with an "overshift" error.  Officially, shifting by 
#	the register width or larger yields an undefined result (NOT undefined 
#	behavior). Is the fact that this is sometimes allowed and sometimes 

#	not an error in the interpreter? TODO2: look into this.  If
#	the result is undefined, I assume the interpreter should replaced it 
#	with a random value of appropriate width.
#
# Inputs:
#   $perl_this: the instance in question (provided by PERL)
# 
# Outputs: none
#
# Return Value: a number n such that 0 <= n < bitwidth
#
# ============================================================================
sub getRandShiftVal
{{
   my( $perl_this )= @_;

   my( $val )= int( rand() * ($perl_this->{'bitwidth'}) );
   return $val;
}}

#template is 16 lines long
## ===========================================================================
## Subroutine sub_name
## ===========================================================================
# Description:
#
# Inputs:
# 
# Outputs:
#
# Return Value:
#
# ============================================================================
#sub sub_name
#{{
#   my( )= @_;
#}}

## ===========================================================================
## Short get subroutines
## ===========================================================================
# Description: short subroutines that only get one field
#
# Inputs: $perl_this: the instance in question (provided by PERL)
#
# Return Value: the field's value
#
# ============================================================================
#sub sub_name {{ my($perl_this)= @_; return $perl_this->{'xx'}; }}
sub getBitwidth {{ my($perl_this)= @_; return $perl_this->{'bitwidth'}; }}
sub getMaxVal {{ my($perl_this)= @_; return $perl_this->{'maxVal'}; }}
sub getMinVal {{ my($perl_this)= @_; return $perl_this->{'minVal'}; }}
sub getName {{ my($perl_this)= @_; return $perl_this->{'name'}; }}

## ===========================================================================
## Short set subroutines
## ===========================================================================
# Description: short subroutines that only set one field
#
# Inputs: the field's new value
#
# Return Value: none
#
# ============================================================================
#sub sub_name
#{{
#   my ($ii)= @_;
#}}




## ****************************************************************************
## end this package 
package main;
## ****************************************************************************
## ****************************************************************************

__END__

=pod

=head1 NAME - generate_llvm_assembler.pl

Generate a random LLVM assembler program

=head1 SYNOPSIS

=cut

# this needs to be a verbatim paragraph, but not be intented too far.
# Therefore begin each line with a space.

=pod

generate_llvm_assembler.pl [debug] [-h|help|-help|--help] [--man] [--revision] 

generate_llvm_assembler.pl [debug] I<options> F<output_file>


=head1 DESCRIPTION

Generates a random LLVM assembler program.  Currently, the program is
a set of linear register assignments, meaning it assigns an arithmetic
result to a register, then uses that result to compute another
arithmetic result for another register, and so forth.

=head2 Options

=over

=item --bitwidth I<n>

Generate code using integer values that are I<n> bits wide.  If
unspecified, a random value will be chosen.

=item --start-poison

Set to force generation of a poison value early in the program.  This
is useful when testing propogation and handling of poison values.

=item --num-steps I<n>

Generate I<n> steps in the program.  The default is 10.

=back

=head1 EXTERNAL INFLUENCES

=cut

# consider adding: NOTES, EXAMPLES, RETURN VALUES & ERROR MESSAGES

#=head1 NEW SECTION

=pod

=head1 FILES

=head1 WARNINGS AND CAVEATS

=head1 BUGS AND DEFICIENCIES

=head1 AUTHOR AND COPYRIGHT

generate_llvm_assembler.pl was written by Christian A. Schreiner.
Copyright (C) 2014-2014 by University of Utah.  You may use, examine,
or modify this software only in accordance with the GNU Public
License, or, alternately, by special arrangement with the author.
generate_llvm_assembler.pl is released without any warranties; if you
use it and something breaks, you are responsible for cleaning up
afterwards.  This notice is precautionary only and does not inherently
imply publication or release for public use.  

=head1 SEE ALSO

perl(1), perldoc(1)

=cut

